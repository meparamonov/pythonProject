# 1. Создать список и заполнить его элементами различных типов данных.
# Реализовать скрипт проверки типа данных каждого элемента.
# Использовать функцию type() для проверки типа.
# Элементы списка можно не запрашивать у пользователя,
# а указать явно, в программе.

# a = 5
# q = 0
# spisok = ['like', 435, [123, 234, 443], a]
# for i in spisok:
#     print(type(spisok[q]))
#     q = q + 1
# print('end')

# 2. Для списка реализовать обмен значений соседних элементов.
# Значениями обмениваются элементы с индексами 0 и 1, 2 и 3 и т. д.
# При нечётном количестве элементов последний сохранить на своём месте.
# Для заполнения списка элементов нужно использовать функцию input().



# spisok2 = input("Введите значение: ")
# str_reverse = ''
# symbols = list(spisok2)
# for el in range(len(spisok2) // 2):
#     tmp = symbols[el]
#     symbols[el] = symbols[len(spisok2) - el - 1]
#     symbols[len(spisok2) - el - 1] = tmp
#     str_reverse = ''.join(symbols)
# print(str_reverse)

# 3. Пользователь вводит месяц в виде целого числа от 1 до 12.
# Сообщить, к какому времени года относится месяц (зима, весна, лето, осень).
# Напишите решения через list и dict.

# mesyac = int(input('Введите номер месяца: '))
# vg = {"весна":[3, 4, 5], 'лето':[6, 7, 8], 'осень':[9, 10, 11], 'зима':[12, 1, 2]}
# for el in vg:
#     if mesyac in vg[el]:
#         print('dict', el)
#
# vg2 = ["весна",'лето','осень', 'зима']
# vg3 = ''
# if mesyac == 3:
#     vg3 = vg2[0]
# elif mesyac == 4:
#     vg3 = vg2[0]
# elif mesyac == 5:
#     vg3 = vg2[0]
# elif mesyac == 5:
#     vg3 = vg2[0]
# elif mesyac == 6:
#     vg3 = vg2[1]
# elif mesyac == 7:
#     vg3 = vg2[1]
# elif mesyac == 8:
#     vg3 = vg2[1]
# elif mesyac == 9:
#     vg3 = vg2[2]
# elif mesyac == 10:
#     vg3 = vg2[2]
# elif mesyac == 11:
#     vg3 = vg2[2]
# elif mesyac == 12:
#     vg3 = vg2[3]
# elif mesyac == 1:
#     vg3 = vg2[3]
# elif mesyac == 2:
#     vg3 = vg2[3]
# print('list', vg3)



# 4. Пользователь вводит строку из нескольких слов,
# разделённых пробелами.
# Вывести каждое слово с новой строки.
# Строки нужно пронумеровать.
# Если слово длинное, выводить только первые 10 букв в слове.

# slova = input('Введите слова через пробел: ').split()
# for i, el in enumerate(slova, 1):
#     print(i, ': ', el[0:9])


# 5. Реализовать структуру «Рейтинг»,
# представляющую собой набор натуральных чисел, который не возрастает.
# У пользователя нужно запрашивать новый элемент рейтинга.
# Если в рейтинге существуют элементы с одинаковыми значениями,
# то новый элемент с тем же значением должен разместиться после них.
# Подсказка. Например, набор натуральных чисел: 7, 5, 3, 3, 2.
# Пользователь ввёл число 3. Результат: 7, 5, 3, 3, 3, 2.
# Пользователь ввёл число 8. Результат: 8, 7, 5, 3, 3, 2.
# Пользователь ввёл число 1. Результат: 7, 5, 3, 3, 2, 1.
# Набор натуральных чисел можно задать сразу в коде, например, my_list = [7, 5, 3, 3, 2].
#
# rate = [7, 5, 3, 3, 2]
# new_rate = int(input('Введите новое значение рейтинга (натуральное число): '))
# inserted = False
# print(f'Исходный список: {rate}')
#
# for i, el in enumerate(rate):
#     if el < new_rate:
#         rate.insert(i, new_rate)
#         print(f'Новое значение {new_rate} вставили на {i} позицию: {rate}')
#         inserted = True
#         break
#
# if not inserted:
#     rate.append(new_rate)
#     print(f'Новое значение {new_rate} добавили в конец списка: {rate}')




# 6. * Реализовать структуру данных «Товары».
# Она должна представлять собой список кортежей.
# Каждый кортеж хранит информацию об отдельном товаре.
# В кортеже должно быть два элемента — номер товара и словарь с параметрами,
# то есть характеристиками товара: название, цена, количество, единица измерения.
# Структуру нужно сформировать программно, запросив все данные у пользователя.
# Пример готовой структуры:
#
# [
# (1, {“название”: “компьютер”, “цена”: 20000, “количество”: 5, “eд”: “шт.”}),
# (2, {“название”: “принтер”, “цена”: 6000, “количество”: 2, “eд”: “шт.”}),
# (3, {“название”: “сканер”, “цена”: 2000, “количество”: 7, “eд”: “шт.”})
# ]
#
# Нужно собрать аналитику о товарах.
# Реализовать словарь, в котором каждый ключ — характеристика товара,
# например, название. Тогда значение — список значений-характеристик,
# например, список названий товаров.
# Пример:
#
# {
# “название”: [“компьютер”, “принтер”, “сканер”],
# “цена”: [20000, 6000, 2000],
# “количество”: [5, 2, 7],
# “ед”: [“шт.”]
# }


goods = []
number = 0

print('Введите одной строкой название товара, цену, количество и единицу измерения')
print('В качестве разделителя позиций используйте только один символ запятой')
print('Значения цены и количества должны быть целочисленными')
print('Для завершения введите пустую строку')

while True:
    number += 1
    good_list = input(f'{number} товар: ').split(',')
    if good_list == ['']:
        break
    # Нужно ли обрабатывать ситуацию, когда введены не 4 позиции? Теоретически такую строку можно отбрасывать
    # и запрашивать повторный ввод

    goods.append((number, {'Наименование': good_list[0],
                           'Цена': int(good_list[1]),
                           'Количество': int(good_list[2]),
                           'Ед. изм.': good_list[3]}))

# Результирующий словарь
goods_dict = {}

for i, el in enumerate(list(goods[0][1].keys())):
    # Собираем для нового словаря названия ключей из первой строки goods
    goods_dict[el] = []

for i, el in enumerate(goods_dict):
    # Пустой список, в который будем записывать значения по каждому ключу
    dict_list = []

    # Собираем значения для текущего ключа результирующего словаря
    for j, el_goods in enumerate(goods):
        key_val = el_goods[1].get(el)

        # Добавляем, только если значения нет в списке
        if key_val not in dict_list:
            dict_list.append(key_val)

    # Записываем в результирующий словарь значение текущего ключа
    goods_dict[el] = dict_list

print(goods_dict)